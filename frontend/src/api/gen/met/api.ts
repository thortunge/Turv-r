/* tslint:disable */
/* eslint-disable */
/**
 * Locationforecast
 * Weather forecast for a specified place
 *
 * The version of the OpenAPI document: 2.0
 * Contact: weatherapi-adm@met.no
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Forecast
 */
export interface Forecast {
    /**
     * 
     * @type {ForecastMeta}
     * @memberof Forecast
     */
    'meta': ForecastMeta;
    /**
     * 
     * @type {Array<ForecastTimeStep>}
     * @memberof Forecast
     */
    'timeseries': Array<ForecastTimeStep>;
}
/**
 * 
 * @export
 * @interface ForecastMeta
 */
export interface ForecastMeta {
    /**
     * 
     * @type {ForecastUnits}
     * @memberof ForecastMeta
     */
    'units': ForecastUnits;
    /**
     * Update time for this forecast
     * @type {string}
     * @memberof ForecastMeta
     */
    'updated_at': string;
}
/**
 * Summary of weather conditions.
 * @export
 * @interface ForecastSummary
 */
export interface ForecastSummary {
    /**
     * 
     * @type {WeatherSymbol}
     * @memberof ForecastSummary
     */
    'symbol_code': WeatherSymbol;
}


/**
 * Weather parameters valid for a specific point in time.
 * @export
 * @interface ForecastTimeInstant
 */
export interface ForecastTimeInstant {
    /**
     * Air pressure at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'air_pressure_at_sea_level'?: number;
    /**
     * Air temperature
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'air_temperature'?: number;
    /**
     * Amount of sky covered by clouds.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction'?: number;
    /**
     * Amount of sky covered by clouds at high elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction_high'?: number;
    /**
     * Amount of sky covered by clouds at low elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction_low'?: number;
    /**
     * Amount of sky covered by clouds at medium elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction_medium'?: number;
    /**
     * Dew point temperature at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'dew_point_temperature'?: number;
    /**
     * Amount of area covered by fog.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'fog_area_fraction'?: number;
    /**
     * Amount of humidity in the air.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'relative_humidity'?: number;
    /**
     * The direction wind is coming from, in degrees clockwise from North
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'wind_from_direction'?: number;
    /**
     * Speed of wind
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'wind_speed'?: number;
    /**
     * Speed of wind gust
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'wind_speed_of_gust'?: number;
}
/**
 * Weather parameters valid for a specified time period.
 * @export
 * @interface ForecastTimePeriod
 */
export interface ForecastTimePeriod {
    /**
     * Maximum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'air_temperature_max'?: number;
    /**
     * Minimum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'air_temperature_min'?: number;
    /**
     * Best estimate for amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'precipitation_amount'?: number;
    /**
     * Maximum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'precipitation_amount_max'?: number;
    /**
     * Minimum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'precipitation_amount_min'?: number;
    /**
     * Probability of any precipitation coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'probability_of_precipitation'?: number;
    /**
     * Probability of any thunder coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'probability_of_thunder'?: number;
    /**
     * Maximum ultraviolet index if sky is clear
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'ultraviolet_index_clear_sky_max'?: number;
}
/**
 * 
 * @export
 * @interface ForecastTimeStep
 */
export interface ForecastTimeStep {
    /**
     * 
     * @type {ForecastTimeStepData}
     * @memberof ForecastTimeStep
     */
    'data': ForecastTimeStepData;
    /**
     * The time these forecast values are valid for. Timestamp in format YYYY-MM-DDThh:mm:ssZ (ISO 8601)
     * @type {string}
     * @memberof ForecastTimeStep
     */
    'time': string;
}
/**
 * Forecast for a specific time
 * @export
 * @interface ForecastTimeStepData
 */
export interface ForecastTimeStepData {
    /**
     * 
     * @type {ForecastTimeStepDataInstant}
     * @memberof ForecastTimeStepData
     */
    'instant': ForecastTimeStepDataInstant;
    /**
     * 
     * @type {ForecastTimeStepDataNext12Hours}
     * @memberof ForecastTimeStepData
     */
    'next_12_hours'?: ForecastTimeStepDataNext12Hours;
    /**
     * 
     * @type {ForecastTimeStepDataNext1Hours}
     * @memberof ForecastTimeStepData
     */
    'next_1_hours'?: ForecastTimeStepDataNext1Hours;
    /**
     * 
     * @type {ForecastTimeStepDataNext6Hours}
     * @memberof ForecastTimeStepData
     */
    'next_6_hours'?: ForecastTimeStepDataNext6Hours;
}
/**
 * Parameters which applies to this exact point in time
 * @export
 * @interface ForecastTimeStepDataInstant
 */
export interface ForecastTimeStepDataInstant {
    /**
     * 
     * @type {ForecastTimeInstant}
     * @memberof ForecastTimeStepDataInstant
     */
    'details'?: ForecastTimeInstant;
}
/**
 * Parameters with validity times over twelve hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext12Hours
 */
export interface ForecastTimeStepDataNext12Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    'details': ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    'summary': ForecastSummary;
}
/**
 * Parameters with validity times over one hour. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext1Hours
 */
export interface ForecastTimeStepDataNext1Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    'details': ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    'summary': ForecastSummary;
}
/**
 * Parameters with validity times over six hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext6Hours
 */
export interface ForecastTimeStepDataNext6Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    'details': ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    'summary': ForecastSummary;
}
/**
 * 
 * @export
 * @interface ForecastUnits
 */
export interface ForecastUnits {
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_pressure_at_sea_level'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_temperature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_temperature_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_temperature_min'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction_high'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction_low'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction_medium'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'dew_point_temperature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'fog_area_fraction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'precipitation_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'precipitation_amount_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'precipitation_amount_min'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'probability_of_precipitation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'probability_of_thunder'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'relative_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'ultraviolet_index_clear_sky_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'wind_from_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'wind_speed'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'wind_speed_of_gust'?: string;
}
/**
 * 
 * @export
 * @interface METJSONForecast
 */
export interface METJSONForecast {
    /**
     * 
     * @type {PointGeometry}
     * @memberof METJSONForecast
     */
    'geometry': PointGeometry;
    /**
     * 
     * @type {Forecast}
     * @memberof METJSONForecast
     */
    'properties': Forecast;
    /**
     * 
     * @type {string}
     * @memberof METJSONForecast
     */
    'type': METJSONForecastTypeEnum;
}

export const METJSONForecastTypeEnum = {
    Feature: 'Feature'
} as const;

export type METJSONForecastTypeEnum = typeof METJSONForecastTypeEnum[keyof typeof METJSONForecastTypeEnum];

/**
 * 
 * @export
 * @interface PointGeometry
 */
export interface PointGeometry {
    /**
     * [longitude, latitude, altitude]. All numbers in decimal.
     * @type {Array<number>}
     * @memberof PointGeometry
     */
    'coordinates': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PointGeometry
     */
    'type': PointGeometryTypeEnum;
}

export const PointGeometryTypeEnum = {
    Point: 'Point'
} as const;

export type PointGeometryTypeEnum = typeof PointGeometryTypeEnum[keyof typeof PointGeometryTypeEnum];

/**
 * A identifier that sums up the weather condition for this time period, see documentation.
 * @export
 * @enum {string}
 */

export const WeatherSymbol = {
    ClearskyDay: 'clearsky_day',
    ClearskyNight: 'clearsky_night',
    ClearskyPolartwilight: 'clearsky_polartwilight',
    FairDay: 'fair_day',
    FairNight: 'fair_night',
    FairPolartwilight: 'fair_polartwilight',
    LightssnowshowersandthunderDay: 'lightssnowshowersandthunder_day',
    LightssnowshowersandthunderNight: 'lightssnowshowersandthunder_night',
    LightssnowshowersandthunderPolartwilight: 'lightssnowshowersandthunder_polartwilight',
    LightsnowshowersDay: 'lightsnowshowers_day',
    LightsnowshowersNight: 'lightsnowshowers_night',
    LightsnowshowersPolartwilight: 'lightsnowshowers_polartwilight',
    Heavyrainandthunder: 'heavyrainandthunder',
    Heavysnowandthunder: 'heavysnowandthunder',
    Rainandthunder: 'rainandthunder',
    HeavysleetshowersandthunderDay: 'heavysleetshowersandthunder_day',
    HeavysleetshowersandthunderNight: 'heavysleetshowersandthunder_night',
    HeavysleetshowersandthunderPolartwilight: 'heavysleetshowersandthunder_polartwilight',
    Heavysnow: 'heavysnow',
    HeavyrainshowersDay: 'heavyrainshowers_day',
    HeavyrainshowersNight: 'heavyrainshowers_night',
    HeavyrainshowersPolartwilight: 'heavyrainshowers_polartwilight',
    Lightsleet: 'lightsleet',
    Heavyrain: 'heavyrain',
    LightrainshowersDay: 'lightrainshowers_day',
    LightrainshowersNight: 'lightrainshowers_night',
    LightrainshowersPolartwilight: 'lightrainshowers_polartwilight',
    HeavysleetshowersDay: 'heavysleetshowers_day',
    HeavysleetshowersNight: 'heavysleetshowers_night',
    HeavysleetshowersPolartwilight: 'heavysleetshowers_polartwilight',
    LightsleetshowersDay: 'lightsleetshowers_day',
    LightsleetshowersNight: 'lightsleetshowers_night',
    LightsleetshowersPolartwilight: 'lightsleetshowers_polartwilight',
    Snow: 'snow',
    HeavyrainshowersandthunderDay: 'heavyrainshowersandthunder_day',
    HeavyrainshowersandthunderNight: 'heavyrainshowersandthunder_night',
    HeavyrainshowersandthunderPolartwilight: 'heavyrainshowersandthunder_polartwilight',
    SnowshowersDay: 'snowshowers_day',
    SnowshowersNight: 'snowshowers_night',
    SnowshowersPolartwilight: 'snowshowers_polartwilight',
    Fog: 'fog',
    SnowshowersandthunderDay: 'snowshowersandthunder_day',
    SnowshowersandthunderNight: 'snowshowersandthunder_night',
    SnowshowersandthunderPolartwilight: 'snowshowersandthunder_polartwilight',
    Lightsnowandthunder: 'lightsnowandthunder',
    Heavysleetandthunder: 'heavysleetandthunder',
    Lightrain: 'lightrain',
    RainshowersandthunderDay: 'rainshowersandthunder_day',
    RainshowersandthunderNight: 'rainshowersandthunder_night',
    RainshowersandthunderPolartwilight: 'rainshowersandthunder_polartwilight',
    Rain: 'rain',
    Lightsnow: 'lightsnow',
    LightrainshowersandthunderDay: 'lightrainshowersandthunder_day',
    LightrainshowersandthunderNight: 'lightrainshowersandthunder_night',
    LightrainshowersandthunderPolartwilight: 'lightrainshowersandthunder_polartwilight',
    Heavysleet: 'heavysleet',
    Sleetandthunder: 'sleetandthunder',
    Lightrainandthunder: 'lightrainandthunder',
    Sleet: 'sleet',
    LightssleetshowersandthunderDay: 'lightssleetshowersandthunder_day',
    LightssleetshowersandthunderNight: 'lightssleetshowersandthunder_night',
    LightssleetshowersandthunderPolartwilight: 'lightssleetshowersandthunder_polartwilight',
    Lightsleetandthunder: 'lightsleetandthunder',
    PartlycloudyDay: 'partlycloudy_day',
    PartlycloudyNight: 'partlycloudy_night',
    PartlycloudyPolartwilight: 'partlycloudy_polartwilight',
    SleetshowersandthunderDay: 'sleetshowersandthunder_day',
    SleetshowersandthunderNight: 'sleetshowersandthunder_night',
    SleetshowersandthunderPolartwilight: 'sleetshowersandthunder_polartwilight',
    RainshowersDay: 'rainshowers_day',
    RainshowersNight: 'rainshowers_night',
    RainshowersPolartwilight: 'rainshowers_polartwilight',
    Snowandthunder: 'snowandthunder',
    SleetshowersDay: 'sleetshowers_day',
    SleetshowersNight: 'sleetshowers_night',
    SleetshowersPolartwilight: 'sleetshowers_polartwilight',
    Cloudy: 'cloudy',
    HeavysnowshowersandthunderDay: 'heavysnowshowersandthunder_day',
    HeavysnowshowersandthunderNight: 'heavysnowshowersandthunder_night',
    HeavysnowshowersandthunderPolartwilight: 'heavysnowshowersandthunder_polartwilight',
    HeavysnowshowersDay: 'heavysnowshowers_day',
    HeavysnowshowersNight: 'heavysnowshowers_night',
    HeavysnowshowersPolartwilight: 'heavysnowshowers_polartwilight'
} as const;

export type WeatherSymbol = typeof WeatherSymbol[keyof typeof WeatherSymbol];



/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {ClassicFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet: async (lat: number, lon: number, format: ClassicFormatGetFormatEnum, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('classicFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('classicFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('classicFormatGet', 'format', format)
            const localVarPath = `/classic.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet: async (lat: number, lon: number, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('classicGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('classicGet', 'lon', lon)
            const localVarPath = `/classic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompactFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet: async (lat: number, lon: number, format: CompactFormatGetFormatEnum, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('compactFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('compactFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('compactFormatGet', 'format', format)
            const localVarPath = `/compact.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet: async (lat: number, lon: number, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('compactGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('compactGet', 'lon', lon)
            const localVarPath = `/compact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompleteFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet: async (lat: number, lon: number, format: CompleteFormatGetFormatEnum, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('completeFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('completeFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('completeFormatGet', 'format', format)
            const localVarPath = `/complete.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet: async (lat: number, lon: number, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('completeGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('completeGet', 'lon', lon)
            const localVarPath = `/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {StatusFormatGetFormatEnum} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet: async (format: StatusFormatGetFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('statusFormatGet', 'format', format)
            const localVarPath = `/status.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {ClassicFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classicFormatGet(lat: number, lon: number, format: ClassicFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classicFormatGet(lat, lon, format, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.classicFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classicGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classicGet(lat, lon, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.classicGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompactFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compactFormatGet(lat: number, lon: number, format: CompactFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compactFormatGet(lat, lon, format, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.compactFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compactGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compactGet(lat, lon, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.compactGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompleteFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeFormatGet(lat: number, lon: number, format: CompleteFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeFormatGet(lat, lon, format, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.completeFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeGet(lat, lon, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.completeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {StatusFormatGetFormatEnum} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusFormatGet(format: StatusFormatGetFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusFormatGet(format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.statusFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Weather forecast for a specified place
         * @param {DataApiClassicFormatGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet(requestParameters: DataApiClassicFormatGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.classicFormatGet(requestParameters.lat, requestParameters.lon, requestParameters.format, requestParameters.altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {DataApiClassicGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet(requestParameters: DataApiClassicGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.classicGet(requestParameters.lat, requestParameters.lon, requestParameters.altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {DataApiCompactFormatGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet(requestParameters: DataApiCompactFormatGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<METJSONForecast> {
            return localVarFp.compactFormatGet(requestParameters.lat, requestParameters.lon, requestParameters.format, requestParameters.altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {DataApiCompactGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet(requestParameters: DataApiCompactGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<METJSONForecast> {
            return localVarFp.compactGet(requestParameters.lat, requestParameters.lon, requestParameters.altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {DataApiCompleteFormatGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet(requestParameters: DataApiCompleteFormatGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<METJSONForecast> {
            return localVarFp.completeFormatGet(requestParameters.lat, requestParameters.lon, requestParameters.format, requestParameters.altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {DataApiCompleteGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet(requestParameters: DataApiCompleteGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<METJSONForecast> {
            return localVarFp.completeGet(requestParameters.lat, requestParameters.lon, requestParameters.altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {DataApiStatusFormatGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet(requestParameters: DataApiStatusFormatGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.statusFormatGet(requestParameters.format, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for classicFormatGet operation in DataApi.
 * @export
 * @interface DataApiClassicFormatGetRequest
 */
export interface DataApiClassicFormatGetRequest {
    /**
     * Latitude
     * @type {number}
     * @memberof DataApiClassicFormatGet
     */
    readonly lat: number

    /**
     * Longitude
     * @type {number}
     * @memberof DataApiClassicFormatGet
     */
    readonly lon: number

    /**
     * format code (file extension)
     * @type {'xml'}
     * @memberof DataApiClassicFormatGet
     */
    readonly format: ClassicFormatGetFormatEnum

    /**
     * Whole meters above sea level
     * @type {number}
     * @memberof DataApiClassicFormatGet
     */
    readonly altitude?: number
}

/**
 * Request parameters for classicGet operation in DataApi.
 * @export
 * @interface DataApiClassicGetRequest
 */
export interface DataApiClassicGetRequest {
    /**
     * Latitude
     * @type {number}
     * @memberof DataApiClassicGet
     */
    readonly lat: number

    /**
     * Longitude
     * @type {number}
     * @memberof DataApiClassicGet
     */
    readonly lon: number

    /**
     * Whole meters above sea level
     * @type {number}
     * @memberof DataApiClassicGet
     */
    readonly altitude?: number
}

/**
 * Request parameters for compactFormatGet operation in DataApi.
 * @export
 * @interface DataApiCompactFormatGetRequest
 */
export interface DataApiCompactFormatGetRequest {
    /**
     * Latitude
     * @type {number}
     * @memberof DataApiCompactFormatGet
     */
    readonly lat: number

    /**
     * Longitude
     * @type {number}
     * @memberof DataApiCompactFormatGet
     */
    readonly lon: number

    /**
     * format code (file extension)
     * @type {'json'}
     * @memberof DataApiCompactFormatGet
     */
    readonly format: CompactFormatGetFormatEnum

    /**
     * Whole meters above sea level
     * @type {number}
     * @memberof DataApiCompactFormatGet
     */
    readonly altitude?: number
}

/**
 * Request parameters for compactGet operation in DataApi.
 * @export
 * @interface DataApiCompactGetRequest
 */
export interface DataApiCompactGetRequest {
    /**
     * Latitude
     * @type {number}
     * @memberof DataApiCompactGet
     */
    readonly lat: number

    /**
     * Longitude
     * @type {number}
     * @memberof DataApiCompactGet
     */
    readonly lon: number

    /**
     * Whole meters above sea level
     * @type {number}
     * @memberof DataApiCompactGet
     */
    readonly altitude?: number
}

/**
 * Request parameters for completeFormatGet operation in DataApi.
 * @export
 * @interface DataApiCompleteFormatGetRequest
 */
export interface DataApiCompleteFormatGetRequest {
    /**
     * Latitude
     * @type {number}
     * @memberof DataApiCompleteFormatGet
     */
    readonly lat: number

    /**
     * Longitude
     * @type {number}
     * @memberof DataApiCompleteFormatGet
     */
    readonly lon: number

    /**
     * format code (file extension)
     * @type {'json'}
     * @memberof DataApiCompleteFormatGet
     */
    readonly format: CompleteFormatGetFormatEnum

    /**
     * Whole meters above sea level
     * @type {number}
     * @memberof DataApiCompleteFormatGet
     */
    readonly altitude?: number
}

/**
 * Request parameters for completeGet operation in DataApi.
 * @export
 * @interface DataApiCompleteGetRequest
 */
export interface DataApiCompleteGetRequest {
    /**
     * Latitude
     * @type {number}
     * @memberof DataApiCompleteGet
     */
    readonly lat: number

    /**
     * Longitude
     * @type {number}
     * @memberof DataApiCompleteGet
     */
    readonly lon: number

    /**
     * Whole meters above sea level
     * @type {number}
     * @memberof DataApiCompleteGet
     */
    readonly altitude?: number
}

/**
 * Request parameters for statusFormatGet operation in DataApi.
 * @export
 * @interface DataApiStatusFormatGetRequest
 */
export interface DataApiStatusFormatGetRequest {
    /**
     * format code (file extension)
     * @type {'json'}
     * @memberof DataApiStatusFormatGet
     */
    readonly format: StatusFormatGetFormatEnum
}

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Weather forecast for a specified place
     * @param {DataApiClassicFormatGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicFormatGet(requestParameters: DataApiClassicFormatGetRequest, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).classicFormatGet(requestParameters.lat, requestParameters.lon, requestParameters.format, requestParameters.altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {DataApiClassicGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicGet(requestParameters: DataApiClassicGetRequest, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).classicGet(requestParameters.lat, requestParameters.lon, requestParameters.altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {DataApiCompactFormatGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactFormatGet(requestParameters: DataApiCompactFormatGetRequest, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).compactFormatGet(requestParameters.lat, requestParameters.lon, requestParameters.format, requestParameters.altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {DataApiCompactGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactGet(requestParameters: DataApiCompactGetRequest, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).compactGet(requestParameters.lat, requestParameters.lon, requestParameters.altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {DataApiCompleteFormatGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeFormatGet(requestParameters: DataApiCompleteFormatGetRequest, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).completeFormatGet(requestParameters.lat, requestParameters.lon, requestParameters.format, requestParameters.altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {DataApiCompleteGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeGet(requestParameters: DataApiCompleteGetRequest, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).completeGet(requestParameters.lat, requestParameters.lon, requestParameters.altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {DataApiStatusFormatGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusFormatGet(requestParameters: DataApiStatusFormatGetRequest, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).statusFormatGet(requestParameters.format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ClassicFormatGetFormatEnum = {
    Xml: 'xml'
} as const;
export type ClassicFormatGetFormatEnum = typeof ClassicFormatGetFormatEnum[keyof typeof ClassicFormatGetFormatEnum];
/**
 * @export
 */
export const CompactFormatGetFormatEnum = {
    Json: 'json'
} as const;
export type CompactFormatGetFormatEnum = typeof CompactFormatGetFormatEnum[keyof typeof CompactFormatGetFormatEnum];
/**
 * @export
 */
export const CompleteFormatGetFormatEnum = {
    Json: 'json'
} as const;
export type CompleteFormatGetFormatEnum = typeof CompleteFormatGetFormatEnum[keyof typeof CompleteFormatGetFormatEnum];
/**
 * @export
 */
export const StatusFormatGetFormatEnum = {
    Json: 'json'
} as const;
export type StatusFormatGetFormatEnum = typeof StatusFormatGetFormatEnum[keyof typeof StatusFormatGetFormatEnum];


/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * RSS feed of changes to this product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changelogGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/changelog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available locations as GeoJSON FeatureCollection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * RSS feed of changes to this product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changelogGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changelogGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.changelogGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthzGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthzGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.healthzGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available locations as GeoJSON FeatureCollection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.locationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.schemaGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * RSS feed of changes to this product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changelogGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changelogGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthzGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List available locations as GeoJSON FeatureCollection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.schemaGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * RSS feed of changes to this product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public changelogGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).changelogGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check health status for product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public healthzGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).healthzGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available locations as GeoJSON FeatureCollection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public locationsGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).locationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schema for XML data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public schemaGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).schemaGet(options).then((request) => request(this.axios, this.basePath));
    }
}



